% ==============================================================================
% PG - Israel dos Santos Candeias
% Capítulo 2 - Referencial Teórico
% ====================================== 2.0 ================================
\chapter{Referencial Teórico e Tecnologias Utilizadas}
\label{sec-referencial}
% Este capítulo deve apresentar os aspectos relativos ao conteúdo teórico relevante para o trabalho.  Incluirá conhecimento adquirido a partir de livros, artigos, relatórios técnicos, dissertações, teses e outros materiais bibliográficos.  O capítulo deve apresentar, além do referencial teórico, informações sobre as tecnologias utilizadas no trabalho. O capítulo deve ter cerca de 12-15 páginas e deve demonstrar conhecimento básico da literatura técnico-científica sobre o tema abordado no trabalho.
Neste capítulo serão apresentados os conceitos teóricos que guiaram o desenvolvimento do jogo, bem como as tecnologias usadas para implementá-lo. No capítulo \ref{sec:engenharia-de-software} abordamos alguns dos conceitos fundamentais de Engenharia de Software e como foram usados neste trabalho; na seção \ref{sec-desenvolvimento-de-jogos} é exposto alguns princípios básicos de desenvolvimento de jogos e as ferramentas e padrões que foram utilizados na programação; a seção \ref{sec-mapas} fala sobre os programas que foram utilizados para o desenvolvimento de mapas desse jogo e a seção \ref{sec:pixel-art} explica como a parte artística do jogo foi feita e, brevemente, explora a ferramenta utilizada.
% colocar os links para as seções explicando oq cada uma fala 

% =============================== 2.1 Princípios de Design de Software ===========================
\section{Engenharia de Software}
\label{sec:engenharia-de-software}
A ideia de um software ter uma arquitetura se tornou importante, de forma a entender como ele foi construído e como suas operações funcionam. Assim como na construção de um prédio ou de um navio, a arquitetura oferece uma maneira de visualizar de forma simples e clara como algo é organizado e estruturado \cite{budgen2020software}. 

A Engenharia de Software é a área da computação que se preocupa em propor e aplicar princípios de engenharia na construção de softwares\cite{engsoftmoderna}, ou seja, é uma área de estudos da computação que se preocupa em projetar, arquitetar e melhorar a qualidade dos produtos de software aumentando assim a produtividade no processo de desenvolvimento. 

Para seguir as práticas recomendadas da engenharia de software, o primeiro passo a ser definido é modelo de processo prescritivo a ser seguido, existem vários modelos para diferentes cenários possíveis como o modelo em cascata, ou o modelo incremental, nesse trabalho foi utilizado como base o modelo de processo evolucionário, mais precisamente o modelo espiral.

Esse modelo tem como característica principal que o diferencia de outros modelos a sua abordagem cíclica tem como objetivo aumentar gradualmente o nível de definição e implementação de um sistema, ao mesmo tempo em que reduz os riscos associados ao seu desenvolvimento. \cite{maxim2021engenharia}. Durante o uso desse modelo, o desenvolvimento do software ocorre por meio de uma série de versões evolutivas, nas primeiras iterações as versões podem ser representadas por modelos ou protótipos. À medida que o processo avança, as iterações subsequentes resultam em versões progressivamente mais completas do sistema, passando por etapas refinadas do processo de engenharia.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\linewidth]{figuras/spiral-model.png}
    \caption{Ciclo de vida do modelo espiral}
    \label{spiral-model}
\end{figure}
Um modelo espiral é dividido em um conjunto de atividades metodológicas, cada uma dessas atividades representa um segmento do caminho espiral ilustrado na Figura \ref{spiral-model} Diferente de outros modelos de processo, que terminam quando o software é entregue, o modelo espiral pode ser adaptado para ser aplicado ao longo de todo ciclo de vida do software.

O primeiro circuito em torno da espiral pode representar um “projeto de desenvolvimento de conceitos” que começa no núcleo da espiral e continua por várias iterações, até que o desenvolvimento de conceitos esteja completo. Se o conceito for desenvolvido para ser um requisito final, o processo prossegue pela espiral pelas “bordas” e um “novo projeto de desenvolvimento de produto” se inicia \cite{maxim2021engenharia}. As ideias precisavam de validação de usuários. Por isso, a prototipação foi muito utilizada como mecanismo de redução de riscos como o modelo sugere. 

% No modelo evolutivo, como o próprio nome sugere, os requisitos vão evoluindo conforme a aplicação evolui e esse processo ocorre em paralelo à evolução da aplicação. Esse paradigma é muito útil quando o cliente não tem todas as funcionalidades necessárias para a solução. Nesse contexto, foi paradigma que mais se adequou a esse trabalho tendo em vista que nem todos os requisitos eram bem definidos de início. Além disto, as funcionalidades do jogo precisam ser validadas frequentemente uma vez que a jogabilidade precisa ser atraente ao público. Portanto, a cada nova versão foram realizadas reuniões com colegas, e com a orientadora, a fim de receber \textit{feedbacks} que auxiliem na melhoria dos recursos, de modo contínuo.

As atividades realizadas no modelo ilustrado na Figura \ref{spiral-model} são:
\begin{itemize}
    \item \textbf{Planejamento:} A fase de planejamento é a base sobre a qual todo o projeto de desenvolvimento de software deve ser construído. Durante essa fase são definidos os recursos um cronograma e a análise de riscos;
    \item \textbf{Modelagem:} Nessa fase elabora-se um "esboço" do sistema, permitindo uma visão geral de sua estrutura e funcionamento;
    \item \textbf{Construção:} Essa etapa envolve a produção do código e a realização de testes para identificar e corrigir possíveis erros na codificação.;
    \item \textbf{Validação:} Ao chegar nessa etapa, O software, seja como uma solução completa ou como um incremento parcialmente implementado, é entregue ao cliente para avaliação. Com base nessa análise, o cliente fornece \textit{feedback} sobre o produto entregue.
\end{itemize}


\section{\textit{Role-Playing Games} (RPG)}
\label{sec:rpg}

Um \textit{role-playing game}\footnote{Role Playing Game \url{https://en.wikipedia.org/wiki/Role-playing_game}} consiste de um tipo de jogo no qual jogadores assumem papéis de algum domínio proposto e devem atuar de acordo com um sistema de regras definido. Há diversos tipo de RPG, com regras e estilos bem variados. As seções a seguir exploram alguns estilos de RPG.

\subsection{RPG de Mesa}
\label{sec:rpg-de-mesa}
Em meados de 1974, nos Estados Unidos, foi publicado um jogo chamado \textit{Dungeons} \& \textit{Dragons} \footnote{D\&D - \textit{Dungeons and Dragons} \url{https://dnd.wizards.com/pt-BR}}. Este jogo foi considerado o primeiro RPG com interpretação de papéis e ambientação em um universo de fantasia medieval.

A ideia do jogo consiste de cada jogador na mesa construir a história, personalidade e ficha de seu personagem; após, o mestre de jogo (ou narrador), que já planejou a história anteriormente, irá dar prosseguimento narrando a história dando início ao jogo, conduzido pela própria imaginação. Os jogadores jogam dados para determinar quais dos seus ataques acertam ou erram e se seu personagem percebe ou não uma armadilha escondida; as ações são determinadas através dos dados. Ou elemento do jogo é a ``ficha de personagem'' que consiste de um documento que deve conter as características que definem os detalhes necessários do personagem de um jogador. Esta ficha determina o quão bom seu personagem é em fazer determinadas ações. Já a história refere-se a um plano de fundo que o jogador inventa para o seu personagem com o intuito de contribuir para um jogo rico em detalhes. 

\subsection{RPG Eletrônico}
\label{sec:rpg-eletronico}
Após o sucesso do RPG de mesa, e com o avanço da tecnologia, esse estilo de jogo saiu da mesa e chegou aos computadores e consoles já não mais precisando depender totalmente da imaginação, pois os computadores renderizam gráficos melhores e mais realistas. Esse estilo de jogo se popularizou e atualmente é um dos gêneros de jogos mais populares segundo a NEWZOO \cite{NEWZOO}.

Atualmente, os RPGs giram em torno de um universo fictício chamado \textit{ambientação} que pode ser medieval, ocidental, espacial, realístico e o que mais a imaginação inventar. Esse universo forma o cenário onde os personagens interagem e constroem a sua história, profissão, cultura e tecnologias \cite{duflo1999jogo}.

\subsection{O RPG na Educação}
\label{sec:rpg-na-educacao}
Esse gênero de jogo tem se destacado não apenas no video-game, mas também como ferramentas versáteis com aplicações em diversas áreas. Caracterizados pela imersão em narrativas interativas e pela personalização de personagens, esses jogos já foram utilizados em diversas áreas fora o entretenimento e tiveram resultados positivos. Por exemplo, na UFG (universidade de Goiás), foi desenvolvido um jogo RPG para o curso de Ciências e Biologia (\cite{soares2016role}) com o objetivo de mediar a aprendizagem, diversificar e avaliar a transmissão do conhecimento. O jogo consiste de uma aventura dentro do corpo humano com 25 questões a respeito de Fisiologia Humana Básica; os alunos do curso demonstram grande interesse pelo jogo e aprovaram o modelo didático e perceberam sua eficácia ao associar a imaginação e a forma como pode ser utilizado para ensinar e avaliar os conhecimentos adquiridos.


%  ================================ 2.2 Princípios de Game Design ================================
% 

% =================== PYGAME-CE =======================================
\section{Desenvolvimento de Jogos}
\label{sec-desenvolvimento-de-jogos}
Um jogo eletrônico é um tipo de aplicativo que normalmente é usado para fins de entretenimento, mas também pode ser projetado para objetivos mais sérios, com potencial de aplicação em diversas áreas, como por exemplo educação, negócios e saúde. Desenvolver um jogo é uma tarefa desafiadora devido às diversas atividades multidisciplinares envolvidas, tornando o processo altamente complexo, como discutido nas seções a seguir. 

\subsection{Princípios de Game Design}
\label{sec:principios-de-game-design}
O processo de aprendizagem envolvido na criação e no desenvolvimento de jogos integra uma ampla variedade de conhecimentos. Para criar um jogo, é fundamental dominar não apenas a programação, mas também áreas como Música, Desenho, inglês, Geometria, Física, Matemática, Lógica, Geografia e Linguagens se tornam indispensáveis, pois o desenvolvimento de um jogo exige o domínio de programação, design gráfico, efeitos sonoros, criação de fases (\textit{level design}), elaboração de histórias e narrativas (\textit{storytelling}), temática e contextualização \cite{cestari2022aprendizagem}.

Nos primeiros dias do desenvolvimento de videogames, os jogos eram criados por grupos pequenos de pessoas; porém, com a complexidade dos jogos aumentando e a industria vendo oportunidades sérias, as equipes eventualmente foram acompanhando o ritmo e a especialização está se tornando cada vez mais necessária à medida que os jogos se tornam maiores. Atualmente, uma equipe de desenvolvimento de jogos engloba profissionais multidisciplinares, cada um com um foco especifico para a produção do jogo. Scott Rogers cita em seu livro \cite{GameDesign} as seguintes: 
\begin{itemize}
    \item \textbf{Programador(a):} Responsável pela programação do software do jogo e das ferramentas utilizadas. Também escreve o documento técnico;
    \item \textbf{Artista:} Responsável pela representação visual dos componentes do jogo desde as interfaces aos personagens estipulados no documento técnico;
    \item \textbf{Designer do Jogo:} cria as ideias e regras que compõem o jogo do conceito até a forma final.
    \item \textbf{Produtor(a): }Responsável por supervisionar toda a equipe de desenvolvimento do jogo;
    \item \textbf{Testador:} Responsável por jogar constantemente o jogo e relatar problemas ou \textit{bugs} encontrados;
    \item \textbf{Compositor:} Aquele responsável por criar temas e tilhas marcantes que sejam capazes de compor o cenário do jogo e passar os sentimentos que o designer do jogo estipulou;
    \item \textbf{Designer de Som:} cria todos os efeitos sonoros que são usados em um jogo;
    \item \textbf{Roteirista:}  Responsável por escrever o manual do jogo e qualquer material de suporte fictício, como  biografias de personagens;
    \item \textbf{Gerente de produto:} Um gerente de produto trabalha com a equipe de desenvolvimento e os gerencia com base no cronograma de produção;
    \item \textbf{Diretor Criativo:} é responsável por toda a gestão criativa de uma marca ou projeto;
    \item \textbf{Diretor(a) de Arte:} Responsável por ajudar a equipe a criar um estilo visual do jogo e trabalham com as equipes de marketing a fim de criar os designs dos produtos;
    \item \textbf{Diretor(a) Técnico:} Revisam e recomendam ferramentas e softwares para equipes para ajudá-las a trabalhar de forma mais eficiente. Eles fornecem suporte técnico e aconselhamento quando há deficiências na equipe.
\end{itemize}

Em um jogo com finalidade pedagógica, é essencial não esquecer de incluir elementos a favor da diversão e do entretenimento utilizando o melhor de todas as áreas citadas anteriormente para essa finalidade. Muitos jogos educacionais infringem este princípio por se preocuparem demais com as questões escolares. Com isso, o jogo se torna chato e o seu propósito não é alcançado. É necessário unir o elemento educacional ao entretenimento para alcançar o objetivo de forma equilibrada.

\subsection{\textit{Game Loop}}
\label{sec:game-loop}
Cada jogo consiste de uma sequência de pegar a entrada do usuário, atualizar o estado do jogo, lidar com a IA, tocar música e efeitos sonoros, e mostrar o jogo na tela. Esta sequência é feita através do \textit{game loop}. Basicamente o \textit{game loop} é o ''batimento cardíaco do jogo''. Cada iteração do loop corresponde a um \textit{frame} (quadro) do jogo, \footnote{Python Brasil \url{https://wiki.python.org.br/GameLoop#:~:text="game%20loop".-,O%20"Game%20Loop",batimento%20cardíaco%20de%20cada%20jogo.}}.

A figura \ref{fig:event-loop} ilustra um loop de jogo com os três elementos básicos, que são executados continuamente a cada volta do loop durante o jogo\footnote{Game Programming Patterns \url{https://gameprogrammingpatterns.com/game-loop.html}}.


\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{figuras/event-loop.png}
    \caption{Event Loop}
    \label{fig:event-loop}
\end{figure}

\begin{itemize}
    \item \textit{\textbf{Input:}} processa a entrada do usuário sem bloqueio;
    \item \textit{\textbf{Update:}} atualiza o estado do jogo;
    \item \textit{\textbf{Render:}}  desenha o jogo;
    \item \textit{\textbf{Delta time:}} o relógio na figura simboliza que este loop é executado a uma velocidade constante. Será explicada a seguir. 
\end{itemize}

% Delta time
\subsection{Delta Time}
\label{sec:delta-time}
Nos primeiros videogames os programadores sabiam exatamente o hardware que iria executar o jogo que eles estavam codificando, o código era escrito especificamente para isso, eles eram cuidadosamente projetados visando fazer apenas o trabalho suficiente em cada quadro para que o jogo rodasse na velocidade que os desenvolvedores queriam. Atualmente é pouco provável saber em qual hardware o jogo será executado, ou seja, quando estivermos codificando um jogo temos que fazer ele se adaptar de forma inteligente a diversos dispositivos.

 Para solucionar isso o \textit{Delta time} (diferença de tempo) é um padrão que a maioria dos jogos utilizam, ela consiste de uma variável com um valor numérico associado correspondente à diferença de valores do último \textit{clock} do processador (\textit{t'}) e o \textit{clock} atual (\textit{t}), como mostrado na equação a seguir.
 \begin{equation}
    \Delta t = t' - t
    \label{eq:dt_equation}
\end{equation}

Supondo que tenhamos dois computadores diferentes para executar o jogo, um potente que consiga rodar a 120 FPS (\textit{frames per second}) quadros por segundo e outro menos potente que execute a 30 FPS. Supondo que a velocidade de movimento seja 1 unidade. Sem o delta time o movimento seria da seguinte forma:
\begin{itemize}
    \item \textbf{Computador Potente:} 1 unidade x 120 quadros = 120 unidades de movimento por segundo.
    \item \textbf{Computador Lento:} 1 unidade x 30 quadros = 30 unidades de movimento por segundo.
\end{itemize}

Se assim fosse feito, o jogador do computador potente se moveria quatro vezes mais rápido em relação ao jogador do computador lento, os jogos seriam injustos e inconsistentes. Veja agora como é feito com o \textit{delta time}.
\begin{itemize}
    \item \textbf{Computador Potente (120FPS):} \( \Delta = \frac{1}{120}\) = 0.0083 
    
    0.0083 x 120 quadros \begin{math} \approx\end{math} 1 unidade.
    \item \textbf{Computador Lento (30FPS):} \( \Delta = \frac{1}{30}\) = 0.0333 
    
    0.0333 x 30 quadros \begin{math} \approx\end{math} 1 unidade.
\end{itemize}

Esse valor é usado para ajustar todas as operações dependentes de tempo, como movimento ou animações.

 % Quando dizemos que um jogo roda a 30 FPS (\textit{frames per second}) quadros por segundo, queremos dizer que o \textit{game loop} é executado 30 vezes por segundo, temos o valor de delta como \(\frac{1}{30}\), o que significa dizer que o \textit{game loop} do jogo leva \(\frac{1}{30}\) segundos para ser executado. Essa informação é utilizada para resolver o problema introduzido pela evolução dos computadores que, hoje, são extremamente mais velozes hoje do que nas décadas de 80 e 90. Jogos desenvolvidos nesta época não rodariam nas máquinas atuais sem um controle temporal do \textit{delta time}. 
 
 % , e se um computador atual executasse um jogo dos anos 80 hoje sem nenhum mecanismo de controle, o jogo rodaria a alguns milhares de quadros e a experiência não seria boa se não fosse utilizado desse \textit{pattern} de jogos, não existiria uma normalidade entre dispositivos.
 
\subsection{Pygame-ce}
\label{sec:pygame-ce}
Pygame-ce (Community Edition) \footnote{https://github.com/pygame-community/pygame-ce/} é uma biblioteca multiplataforma gratuita e de código aberto que surgiu de um \textit{fork} do projeto \textit{pygame} por seus antigos desenvolvedores principais. Seu foco é construir aplicativos multimídia como videogames utilizando a linguagem Python. A biblioteca está sob a licença GNU LGPL version 2.1, o que significa que pode ser usada em qualquer projeto desde que, se forem feitas quaisquer alterações ou adições ao código-fonte, elas devem ser lançadas com uma licença compatível. 
 A Pygame-ce usa a biblioteca SDL (Simple DirectMedia Layer)\footnote{SDL (Simple DirectMedia Layer) \url{https://www.libsdl.org/}} que consiste de uma biblioteca de desenvolvimento multiplataforma também de código aberto e escrita em C, projetada para fornecer acesso de baixo nível a hardware de áudio, teclado, mouse, \textit{joystick} e gráficos via OpenGL e Direct3D além de várias outras bibliotecas populares para abstrair as funções mais comuns. A SDL age como um \textit{wrapper} de camada fina e multiplataforma, fornecendo suporte a operações de pixel 2D, som, acesso à arquivos, manipulação de eventos, temporizadores e \textit{threading}.
As principais funcionalidades da \textit{pygame} incluem:
\begin{itemize}
    \item Carregamento e exibição de imagens;
    \item Criação de animações e renderização quadros de jogos;
    \item Adição de música de fundo e efeitos sonoros;
    \item Manipulação de dispositivos de entrada;
    \item Gerenciamento de \textit{sprites} através de classes integradas.
\end{itemize}

Como a maioria das bibliotecas de python, \textit{pygame} pode ser adicionada via \textit{prompt} de comandos do sistema operacional  por meio do pip\footnote{pip \url{https://pip.pypa.io/en/stable/}}. O pip é um sistema de gerenciamento de pacotes para Python, usado para instalar e gerenciar pacotes de software escritos na linguagem de programação Python. Ele simplifica o processo de instalação, atualização e remoção de pacotes e suas dependências. A listagem \ref{lst-circle-movement} mostra um exemplo de código Pygame inicial para desenhar um circulo na tela e movimenta-lo \footnote{Pygame Docs \url{https://pyga.me/docs/}}. 

\newpage
\lstinputlisting[label=lst-circle-movement, caption=Exemplo de código Pygame Para Mover um Circulo., language=Python, float=htpb]{codigos/circle_movement.py}
% completar aqui
Na linha (2) é feito a importação do pygame e dizemos ao compilador para carregar os seus módulos; nas linhas (5) à (8) fazemos a inicialização básica de todo código pygame onde inicializamos o pygame configuramos a tela inicial, configuramos as variáveis de controle \textit{clock} e \textit{running}; a linha (11) é definida a posição inicial do círculo, na linha (13) é onde começa o \textit{loop} principal do jogo que consiste em:
\begin{enumerate}
    \item verificar se o jogador fechou o jogo (linhas 16 a 18);
    \item preencher toda a tela com a cor roxa (linha 21);
    \item desenhar o círculo vermelho na posição \textit{player\_pos} (linha 23);
    \item fazer a captura da entrada do jogador (25) e se for o alguma das ("w", "s", "a", "d") move o círculo a respectiva direção (linhas 26 a 33);
    \item a linha (36) atualiza o conteúdo de toda essa exibição;
    \item atualizamos o valor do \textit{delta\_time} como explicado na seção \ref{sec:delta-time} este método que deve ser chamado uma vez por \textit{frame} e retornará quantos milissegundos se passaram desde a chamada anterior, como passamos o valor 60 de parâmetro, o jogo não passará de 60 FPS.
\end{enumerate}
% coisas para explicar?
% colocar um codigo com \href{https://pyga.me/docs/ref/music.html}{pygame.mixer.música} \href{https://pyga.me/docs/ref/draw.html}{pygame.draw} 
% \href{https://pyga.me/docs/ref/event.html}{pygame.event} 
% \href{https://pyga.me/docs/ref/font.html}{pygame.font} 
% \href{https://pyga.me/docs/ref/image.html}{pygame.image} 
% \href{https://pyga.me/docs/ref/key.html}{pygame.key} 
% \href{https://pyga.me/docs/ref/rect.html}{pygame.Rect} 
% \href{https://pyga.me/docs/ref/sprite.html}{pygame.sprite} 
% \href{https://pyga.me/docs/ref/surface.html}{pygame.Surface} 
% \href{https://pyga.me/docs/ref/transform.html}{pygame.transform} 
% \href{https://pyga.me/docs/ref/window.html}{pygame.Window} 
% completar aqui
%  ======================================= 2.3 Mapas =================================

\section{Mapas}
\label{sec-mapas}
% explicar oq e um editor de mapas

Os mapas de jogo desempenham um papel fundamental no design e na experiência de um jogo, servindo como o alicerce do mundo virtual onde a narrativa, os desafios e a exploração ocorrem. Os mapas ajudam a transmitir a ambientação, geografia e lógica do universo do jogo proporcionando imersão e ambientação do jogador. Para a criação de mapas são utilizadas ferramentas que auxiliam nesse processo, esses são os editores de mapas.

 Os softwares editores de mapas permitem o designer do criar de forma visual e intuitiva os mapas de seus jogos. Praticamente todos os jogos usam uma ferramenta para esse propósito, tanto jogos 2D como também jogos 3D. Nesse trabalho  utilizou-se de editor 2D. Um editor de mapas 2D se fundamenta em uma técnica denominada \textit{Tile-Based}, onde o cenário é formado por pequenas imagens quadradas, retangulares ou hexagonais chamados \textit{tiles} (ladrilhos). .
% citar jogos populares que utilizam essa técnica (dofus)

\subsection{\textit{Tiles} e \textit{Tilesets}}
\label{sec:tiles-e-tilesets}
% explicar jogos 2d  podem ter dois tipos, 
\textit{Tilesets} são coleções de pequenas imagens reutilizáveis, chamados ''tiles'', organizadas em uma grade. Cada \textit{tile} representa uma pequena parte do mundo de um jogo 2D, por exemplo, um pedaço de chão, um segmento de uma parede ou uma decoração. Ao combinar diferentes tiles em diferentes posições temos um cenário que pode ser utilizado como fase de um jogo. 

Trata-se de um recurso gráfico para desenhar níveis e outros componentes estáticos de um jogo de forma rápida e eficiente, já que não é necessário desenhar toda a área jogável. Esses \textit{tilesets} podem ser essencialmente duas formas: i) \textit{\textbf{top-down}} (cima para baixo) esses tiles são desenhados na perspectiva vista de cima para baixo, alguns jogos que utilizam desse tipo de tile são \textit{The Legend of Zelda} e \textit{Chrono Trigger} veja a figura \ref{fig:tileset-orthogonal} e ii) \textit{\textbf{platformer}} (plataforma) esses tiles são desenhados na perspectiva de lado utilizada em jogos onde o jogador realiza saltos e desvia de obstáculos é o caso de jogos como \textit{Super Mario} e \textit{Sonic} a figura \ref{fig:tileset-platform-orthogonal} ilustra esse tipo de \textit{tile}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\linewidth]{figuras/tileset.png}
    \caption{Exemplo de \textit{tileset top-down}}
    \label{fig:tileset-orthogonal}
\end{figure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\linewidth]{figuras/tileset-orthogonal-platform.png}
    \caption{Exemplo de \textit{tileset platformer}}
    \label{fig:tileset-platform-orthogonal}
\end{figure}

\clearpage
\subsection{Tiled}
\label{sec:tiled}
O Tiled \footnote{Tiled \textit{Map Editor} \url{https://www.mapeditor.org}} é um editor de mapas 2D de software aberto (confirmar aqui) que ajuda \textit{game designers} a desenvolverem o conteúdo de seus jogos. Seu principal recurso é desenhar editar mapas de \textit{tiles} de várias formas. O software também suporta posicionamento de imagens livres, e tem maneiras eficientes de colocar metadados em seus \textit{sprites} que futuramente poderão serem usados pelo programador.

Tiled suporta camadas de tiles retangulares, retas, isométricas projetadas, isométricas escalonadas e hexagonais escalonadas \cite{tiled}.
% No programa para carregar um \textit{tileset} pode ser uma única imagem contendo muitos tiles divididos por  ou pode ser uma coleção de imagens individuais.% 
O Tiled também é capaz de suportar algumas técnicas de simulação de profundidade por meio do deslocamento de camadas e alteração da ordem de renderização dos componentes.

O Tiled suporta camadas de objetos, que podem ser usadas para colocar imagens: é possível adicionar objetos como retângulos, pontos, elipses, polígonos, polilinhas e ladrilhos, que podem ser dimensionados ou girados. A Figura \ref{fig:map-creation} mostra uma configuração inicial de criação de um mapa.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\linewidth]{figuras/new-map-tiled.png}
    \caption{Criação de mapa}
    \label{fig:map-creation}
\end{figure}
% As características mais importantes a serem destacadas nessa tela são:
% \begin{itemize}
%     \item \textbf{Orientação (Orientation):} A orientação define como é o estilo de visualização do seu jogo, sendo possíveis 4 estilos “ortogonal”, “isométrico”, “escalonado” e “hexagonal”;
%     \item \textbf{Tamanho do mapa \textit{(Map Size}):} nessa parte é definido o tamanho do mapa, é possível alterar os valores no decorrer da criação, o próprio software faz o calculo de quantos pixels o mapa ficará, na figura cada tile tem 32 píxels de tamanho, e o mapa é um quadrado 10 x 10 , sendo assim o tamanho final do mapa é 320 x 320
%     \item \textbf{Tamanho do tile \textit{(Tile Size)}:}, essa é a informação mais importante dessa página, é nessa opção que se define o tamanho do tile que vai ser representado na tela, isso significa que cada azulejo do mapa terá exatamente esse tamanho, quando for a  hora de importar o tileset para o programa é importante garantir que o  tileset tem o mesmo tamanho do tile do mapa.
% \end{itemize}
% Com o mapa em branco criado agora é necessário importar um tileset para começar a desenhar o mapa a figura \ref{fig:new-tileset}  ilustra esse processo.
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.5\linewidth]{figuras/new-tileset.png}
%     \caption{Enter Caption}
%     \label{fig:new-tileset}
% \end{figure}
% As Informações mais importantes aqui são:
% \begin{itemize}
%     \item \textbf{Procurar \textit{(Browse)}:} nessa opção você vai carregar o arquivo para o programa;
%     \item \textbf{Tipo \textit{(Type)}:} aqui dizemos ao programa se é uma imagem única com múltiplos tilesets, ou uma imagem única;
%     \item \textbf{Largura do Tile e Altura do tile \textit{(Tile Width)} \textit{(Tile Height)}:} Nessa parte você está dizendo ao programa como "fatiar" a imagem que está recebendo, dividindo assim em vários azulejos únicos reutilizáveis, com essas configurações ficamos com um algo assim;
%     \begin{figure}[h!]
%         \centering
%         \includegraphics[width=0.8\linewidth]{figuras/tileset-dividido.png}
%         \caption{Tileset dividido}
%         \label{fig:tileset-dividido}
%     \end{figure}
% \end{itemize}

\subsection{Camadas}
\label{sec:camadas}
Camadas ou \textit{layers} no Tiled definem a ordem com que os \textit{tiles} e \textit{sprites} serão desenhadas na tela de forma \textit{bottom-up}, ou seja, os \textit{tiles} serão renderizados de baixo para cima de forma que, em caso de blocos sobrepostos, o que está mais acima tem prioridade. A figura \ref{fig:layers} mostra as camadas relativas a um mapa de exemplo (i) terreno, (ii) topo do terreno (iii) objetos e (iv) entidades. 
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{figuras/layers.png}
    \caption{Camadas no Tiled}
    \label{fig:layers}
\end{figure}

Existem 4 possíveis tipos de camadas no Tiled, duas delas foram utilizadas nesse trabalho: 
\begin{itemize}
    \item \textbf{(i) Camada de tiles}: é nela que são feitos os terrenos do jogo bem como as coisas acima do terreno e sem colisão. São as camadas ``\textit{Terrain}'' e ``\textit{Terrain} Top'' mostradas na figura \ref{fig:layers};
    \item \textbf{(ii) Camada de objetos} usadas para posicionar objetos e personagens ``\textit{Entities}'' e ``\textit{Objects}'' da figura \ref{fig:layers}. Nessa camada, é possível adicionar metadados que podem ser usados no código para identificação de e manejo desses \textit{sprites}.
\end{itemize}

% dados com chave/valor aos dados presentes aqui, a figura \ref{fig:add-custom-property-object} exemplifica como adicionar uma propriedade "quebrável" a uma caixa.
% \begin{figure}[h!]
%     \caption{Adicionando uma propriedade personalizada a um objeto}
%     \label{fig:add-custom-property-object}
%     \subfloat{
%         \includegraphics[width=0.35\linewidth]{figuras/example-map.png}
%     }\hfill
%     \subfloat{
%         \includegraphics[width=0.5\linewidth]{figuras/custom-property.png}
%     }
% \end{figure}
% Ao salvar essas configurações o programa gera um arquivo com a extensão '.tmx' que é o acrônimo de Translation Memory eXchange, é um formato baseado no 'xml' devido a isso faz o uso de tags e atributos de arquivo padrão usado na indústria de tradução para armazenar e trocar memórias de tradução, basicamente consiste em uma seção de cabeçalho, seguido por uma ou várias seções de corpo, cada uma contendo unidades de tradução. A listagem a seguir ilustra isso.

% \newpage
% \begin{lstlisting}[language=xml,breaklines, caption= example.tmx terrain layer]
% <?xml version="1.0" encoding="UTF-8"?>
% <map version="1.10" tiledversion="1.11.0" orientation="orthogonal" renderorder="right-down" width="20" height="16" 
% tilewidth="16" tileheight="16" infinite="0" nextlayerid="5" nextobjectid="7">
%  <tileset firstgid="1" name="Terrain (16x16)" tilewidth="16" tileheight="16" tilecount="242" columns="22">
%   <image source="Free/Terrain/Terrain (16x16).png" width="352" height="176"/>
%  </tileset>
%  <tileset firstgid="243" name="images" tilewidth="28" tileheight="24" tilecount="1" columns="0">
%   <grid orientation="orthogonal" width="1" height="1"/>
%   <tile id="0">
%    <image source="Free/Items/Boxes/Box1/Idle.png" width="28" height="24"/>
%   </tile>
%  </tileset>
%  <tileset firstgid="244" name="Blue" tilewidth="16" tileheight="16" tilecount="16" columns="4">
%   <image source="Free/Background/Blue.png" width="64" height="64"/>
%  </tileset>
%  <layer id="1" name="Terrain" width="20" height="16">
% \end{lstlisting}

% \begin{lstlisting}[language=xml,breaklines, caption= example.tmx object layer]
%  <objectgroup id="3" name="Objects">
%   <object id="4" gid="243" x="153" y="147.25" width="28" height="24"/>
%   <object id="5" gid="243" x="172.5" y="147.25" width="28" height="24"/>
%   <object id="6" gid="243" x="163.75" y="128.25" width="28" height="24">
%    <properties>
%     <property name="breakable" type="bool" value="true"/>
%    </properties>
%   </object>
%  </objectgroup>
% \end{lstlisting}


%parei aqui, continuo amanhã

%  ======================================= PyTMX =======================================
\subsection{PyTMX}
\label{sec:pytmx}
Pytmx é um software livre sobre a licença GNU Lesser General Public License (Licença Pública Geral Menor, em tradução livre) \footnote{LGPL Lesser General Public License\url{https://juristas.com.br/foruns/topic/significado-de-lgpl-lesser-general-public-license/}}
PyTMX\footnote{PyTMX \url{https://pytmx.readthedocs.io/en/latest/}} é um carregador de mapas para python/pygame, projetado para jogos. Este software apoia o carregamento inteligente de \textit{tiles} com uma base de armazenamento rápida e eficiente. O PyTMX tem a capacidade de manipular a maioria dos tipos de objetos \textit{Tiled} com metadados. Isso é importante para que seja possível modificar mapas e objetos no Tiled, sem a necessidade de modificar código-fonte.

% \begin{lstlisting}[language=bash,breaklines, caption= Instalação Pytmx]
% pip install pytmx
% \end{lstlisting}

% \begin{lstlisting}[language=python,breaklines, caption= Uso Básico Pytmx]
% import pytmx

% tmxdata = pytmx.TiledMap("example.tmx")

% print(tmxdata.width)
% print(tmxdata.height)
% print(tmxdata.tilewidth)
% print(tmxdata.orientation)
% print(tmxdata.layernames)
% \end{lstlisting}

% \begin{lstlisting}[language=bash,breaklines, caption= Saída]
% >>> 20
% >>> 16
% >>> 16
% >>> orthogonal
% >>> {'Terrain': <TiledTileLayer[1]: "Terrain">, 'Terrain Top': <TiledTileLayer[2]: "Terrain Top">, 'Objects': <TiledObjectGroup[3]: "Objects">, 'Entities': <TiledObjectGroup[4]: "Entities">}
% \end{lstlisting}

% Para podermos usar esse mapa é necessário anteriormente importarmos ele para dentro do código isso é feito na linha 1, na linha 3 criamos uma variável para armazenar o mapa, e com isso temos acesso as informações presentes naquele mapa.

% Agora para termos acesso aos metadados presentes na camada de objetos, por exemplo, podemos fazer uma iteração e verificação do nome do \textit{layer} com isso temos acesso aos objetos quebráveis.
% \begin{lstlisting}[language=python,breaklines, caption= Verificação de Objetos Quebráveis]
% for layer in tmxdata.visible_layers:
%     if layer.name == 'Objects':
%         for obj in layer:
%             print(obj.properties['breakable'], obj.x, obj.y)
% \end{lstlisting}

% \begin{lstlisting}[language=bash,breaklines, caption= Saída]
% >>> True 163.75 104.25
% >>> True 152.25 123.0
% >>> True 172.5 123.25
% \end{lstlisting}

%  ======================================= Pixel Art ===================================
\section{Pixel Art}
\label{sec:pixel-art}
A Pixel Art surgiu nos anos 60 mas foi popularizada nos anos 70 e 80. Nessa época de início dessas tecnologia, os monitores ainda não tinham a quantidade de pixels da atualidade. Era necessário desenhar objetos na tela com ''quadradinhos'' uma vez que era o único recurso que da época. Contudo, até nos dias atuais, é um estilo de arte que milhares de pessoas apreciam. Na figura \ref{fig:mario} vemos alguns exemplos de Pixel Arts.

O termo \textit{pixel}, originado de (\textit{picture} e \textit{element}), ou seja, elemento de imagem, é a menor unidade de uma imagem que é possível ser expressa digitalmente \cite{lyon2006brief}. A \textit{Pixel Art} consiste de um tipo de arte que usa pixels visíveis para compor uma imagem ou um vídeo, que é formado pela junção de diversos pontos digitais.

Em um monitor que permite imagens coloridas, cada pixel é composto por um conjunto de 3 cores: vermelho, verde e azul. Em bons monitores cada uma dessas cores é capaz de exibir 256 tonalidades diferentes (o equivalente a 8 bits). A partir da combinação dessas tonalidades é possível exibir pouco mais de 16.7 milhões de cores diferentes \(256 * 256 * 256\). A quantidade de pixels a serem mostradas na tela depende do tamanho do \textit{display}, por exemplo, em uma resolução HD (1280 x 720) temos 921.600 pixels, numa resolução 8K (7680 x 4320) temos 33.177.600 a serem preenchidos.


\begin{figure}[ht!]
    \caption{Exemplos de diferentes pixel arts em suas gerações esquerda Super Mario 8-bits (NES) /  Mega Man x4 32-bits (Playstation 1)}
    \label{fig:comparative-8bit-32-bit-pixel-art}
    \subfloat\label{fig:mario}1985.{
        \includegraphics[width=0.35\linewidth]{figuras/mario-sprite-nes.png}
    }\hfill
    \subfloat\label{fig:mega_man}1998{
        \includegraphics[width=0.3\linewidth]{figuras/mega-man-ps1.png}
    }
\end{figure}

\newpage
\subsection{Aseprite}  
\label{sec:aseprite}
% Para fazer um jogo é necessário ter sprites 
O Aseprite\footnote{Aseprite \url{https://www.aseprite.org}} é um software comercial especializado em Pixel Art que oferece recursos e ferramentas específicas para essa finalidade permitindo, assim, a criação de animações 2D para videogames, como o exemplo da figura \ref{fig:aseprite}. As ferramentas de Aseprite conseguem controlar
a animação quadro-a-quadro e fazer rotações de pixel art pré-desenvolvidas.
ilustra a tela básica do programa, a primeira vista ele é similar a outros programas de criação de imagens com exceção da grade quadriculada.  
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\linewidth]{figuras/aseprite.jpg}
    \caption{Visão Básica Aseprite}
    \label{fig:aseprite}
\end{figure}

Um \textit{Sprite} é um objeto gráfico bidimensional (2D) usado em computação gráfica e, particularmente, em videogames. Um sprite normalmente consiste de uma imagem de bitmap ou uma série de imagens que são combinadas para criar uma animação. Um sprite também pode ser pensado como uma entidade separada que existe dentro de uma cena maior. Especificamente no Aseprite, um sprite consiste de uma sequência de quadros somados em uma pilha de camadas. A intersecção de quadros e camadas cria uma matriz de células gráficas editáveis com imagens/pixels que podem ser editados com o editor de sprites . Camadas, quadros e células são visíveis na linha do tempo
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{figuras/sprite-frog.png}
    \caption{Ninja Frog Sprite de Pulo}
    \label{fig:enter-label}
\end{figure}


\subsection{Animação}
\label{sec:animacao}
 A animação é a ilusão de movimento que nossos cérebros nos enganam para perceber quando vemos vários quadros de obras de arte estáticos reproduzidos em rápida sucessão.
Um quadro é uma única imagem estática em um sprite, se adicionarmos e alterarmos os quadros a uma certa velocidade, cria-se a a impressão de movimento, ao qual dá-se o nome de Animação. 
Em programação existem várias formas de fazer a animação e uma delas é através de vetores; essa técnica consiste em carregar uma imagem e dizemos ao computador que queremos dividir essa imagem e armazena-lo num vetor, a figura \ref{fig:sprite-animation} exemplifica isso, nesse caso um vetor de duas linhas e cinco colunas, assim para fazer a animação desse personagem, basta percorrer as imagens alternadamente enquanto capturamos a entrada do jogador e vemos se é movimento

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\linewidth]{figuras/megaman-sprite-animation-export.png}
    \caption{Sprite Animation}
    \label{fig:sprite-animation}
\end{figure}






